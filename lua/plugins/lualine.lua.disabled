-- Lualine status line configuration

return {
  "nvim-lualine/lualine.nvim",
  dependencies = { "nvim-tree/nvim-web-devicons", "catppuccin/nvim" },
  config = function()
    local colors = require("catppuccin.palettes").get_palette()
    
    require("lualine").setup({
      options = {
        theme = "catppuccin",
        component_separators = { left = "│", right = "│" },
        section_separators = { left = "", right = "" },
        globalstatus = true,
        refresh = {
          statusline = 1000,
          tabline = 1000,
          winbar = 1000,
        },
      },
      sections = {
        lualine_a = {
          {
            "mode",
            fmt = function(str)
              local mode_map = {
                NORMAL = "N",
                INSERT = "I", 
                VISUAL = "V",
                ["V-LINE"] = "VL",
                ["V-BLOCK"] = "VB",
                COMMAND = "C",
                REPLACE = "R",
                TERMINAL = "T",
              }
              return mode_map[str] or str:sub(1,1)
            end,
            padding = { left = 1, right = 1 },
          }
        },
        lualine_b = {
          {
            "branch",
            icon = "",
            color = { fg = colors.lavender },
          },
          {
            "diff",
            symbols = { added = " ", modified = " ", removed = " " },
            diff_color = {
              added = { fg = colors.green },
              modified = { fg = colors.yellow },
              removed = { fg = colors.red },
            },
          },
        },
        lualine_c = {
          {
            "filename",
            file_status = true,
            newfile_status = false,
            path = 1, -- relative path
            symbols = {
              modified = "●",
              readonly = "",
              unnamed = "[No Name]",
              newfile = "[New]",
            },
          },
        },
        lualine_x = {
          {
            "diagnostics",
            sources = { "nvim_lsp" },
            symbols = { error = " ", warn = " ", info = " ", hint = " " },
            diagnostics_color = {
              error = { fg = colors.red },
              warn = { fg = colors.yellow },
              info = { fg = colors.blue },
              hint = { fg = colors.teal },
            },
          },
        },
        lualine_y = {
          {
            "filetype",
            colored = true,
            icon_only = false,
            padding = { left = 1, right = 1 },
          },
        },
        lualine_z = {
          {
            "progress",
            padding = { left = 1, right = 0 },
          },
          {
            "location",
            padding = { left = 0, right = 1 },
          },
        },
      },
      inactive_sections = {
        lualine_a = {},
        lualine_b = {},
        lualine_c = { 
          {
            "filename",
            file_status = true,
            path = 1,
          }
        },
        lualine_x = { "location" },
        lualine_y = {},
        lualine_z = {},
      },
      extensions = { "oil", "mason", "lazy" },
      disabled_filetypes = {
        statusline = { "dashboard", "snacks_dashboard", "snacks_dashbaord" },
        winbar = { "dashboard", "snacks_dashboard", "snacks_dashbaord" },
      },
    })
    
    -- Nuclear approach: check every possible way to detect dashboard
    vim.api.nvim_create_autocmd({ "FileType", "BufEnter", "BufWinEnter", "WinEnter", "TermClose", "VimEnter" }, {
      group = vim.api.nvim_create_augroup("LualineRefresh", { clear = true }),
      callback = function(ev)
        -- Wait a bit for everything to settle
        vim.defer_fn(function()
          local current_buf = vim.api.nvim_get_current_buf()
          local ft = vim.bo[current_buf].filetype
          local bufname = vim.api.nvim_buf_get_name(current_buf)
          local lines = vim.api.nvim_buf_get_lines(current_buf, 0, -1, false)
          
          -- Debug: let's see what we're dealing with
          local has_neovim_ascii = false
          for _, line in ipairs(lines) do
            if line:match("NEOVIM") or line:match("Find File") then
              has_neovim_ascii = true
              break
            end
          end
          
          -- If it looks like a dashboard, NUKE everything
          if ft == "dashboard" or ft == "snacks_dashboard" or 
             bufname:match("snacks_dashboard") or has_neovim_ascii or
             (bufname == "" and vim.bo[current_buf].buftype == "nofile") then
            
            -- NUCLEAR OPTION: destroy all status things
            vim.cmd([[
              set laststatus=0
              set noruler
              set noshowcmd  
              set noshowmode
              set statusline=
            ]])
            return
          end
          
          -- Restore for normal files
          vim.cmd([[
            set laststatus=2
            set ruler
            set showcmd
            set showmode  
            set statusline=
          ]])
          require("lualine").refresh()
        end, 150)
      end,
    })
  end,
}